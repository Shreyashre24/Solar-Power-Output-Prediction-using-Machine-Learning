# -*- coding: utf-8 -*-
"""Soalr power output predcition using ml .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10TB4RFEkeR2Ob-amW5dydTdUCZNJiyTH
"""

import numpy as np
import pandas as pd
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
import warnings
warnings.filterwarnings("ignore")

# ---------- Data Simulation ----------
def generate_solar_data(days=365, seed=42):
    np.random.seed(seed)
    hours = np.arange(0, 24*days)
    # Daily cycle (sinusoidal for sunlight hours)
    radiation = np.maximum(0, np.sin((hours % 24 - 6) * np.pi/12))
    # Add random clouds
    radiation = radiation * (0.8 + 0.4*np.random.rand(len(radiation)))
    # Seasonal effect (summer more intense, monsoon lower)
    season = 1 + 0.3*np.sin(2*np.pi*hours/(24*365))
    radiation *= season
    # Temperature effect
    temp = 25 + 10*np.sin(2*np.pi*hours/24) + 5*np.sin(2*np.pi*hours/(24*365))
    # Panel efficiency drop if temp > 35
    efficiency = np.where(temp > 35, 0.9, 1.0)
    # Final power
    power = radiation * efficiency * 100  # scale factor
    df = pd.DataFrame({
        'hour': hours,
        'radiation': radiation,
        'temp': temp,
        'power': power
    })
    return df

# ---------- Feature Engineering ----------
def make_features(df, lags=[1,2,3]):
    data = df.copy()
    for lag in lags:
        data[f'lag_{lag}'] = data['power'].shift(lag)
    data = data.dropna().reset_index(drop=True)
    return data

# ---------- Evaluation ----------
def evaluate(y_true, y_pred, eps=1e-6):
    y_true = np.asarray(y_true)
    y_pred = np.asarray(y_pred)
    mae = mean_absolute_error(y_true, y_pred)
    mse = mean_squared_error(y_true, y_pred)
    rmse = np.sqrt(mse)
    mape = np.mean(np.abs((y_true - y_pred) / np.maximum(np.abs(y_true), eps))) * 100.0
    r2 = r2_score(y_true, y_pred)
    return {'MAE': mae, 'RMSE': rmse, 'MAPE': mape, 'R2': r2}

# ---------- Pipeline ----------
def run_pipeline(df, seq_lags=[1,2], test_days=30, random_state=42):
    data = make_features(df, lags=seq_lags)
    train = data.iloc[:-24*test_days]
    test  = data.iloc[-24*test_days:]

    X_train, y_train = train.drop('power', axis=1), train['power']
    X_test, y_test   = test.drop('power', axis=1), test['power']

    results = {}

    # Persistence (last value as prediction)
    y_pred_persistence = test['lag_1']
    results['Persistence'] = evaluate(y_test, y_pred_persistence)

    # Linear Regression
    lr = LinearRegression()
    lr.fit(X_train, y_train)
    results['LinearRegression'] = evaluate(y_test, lr.predict(X_test))

    # Random Forest
    rf = RandomForestRegressor(n_estimators=100, random_state=random_state)
    rf.fit(X_train, y_train)
    results['RandomForest'] = evaluate(y_test, rf.predict(X_test))

    return pd.DataFrame(results).T  # return as nice table

# ---------- Run with datasets ----------
if __name__ == "__main__":
    df_small = generate_solar_data(10)
    df_mid   = generate_solar_data(35)
    df_long  = generate_solar_data(180)
    df_year  = generate_solar_data(365)

    print("\nRunning pipeline on 10-day dataset")
    print(run_pipeline(df_small, seq_lags=[1,2], test_days=2, random_state=0))

    print("\nRunning pipeline on 35-day dataset")
    print(run_pipeline(df_mid, seq_lags=[1,2], test_days=7, random_state=1))

    print("\nRunning pipeline on 180-day dataset")
    print(run_pipeline(df_long, seq_lags=[1,2,3], test_days=30, random_state=2))

    print("\nRunning pipeline on 365-day dataset (full year with seasons + monsoon)")
    print(run_pipeline(df_year, seq_lags=[1,2,3], test_days=60, random_state=3))

